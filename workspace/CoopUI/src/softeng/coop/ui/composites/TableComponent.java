package softeng.coop.ui.composites;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Vector;

import softeng.coop.ui.ICoopContext;
import softeng.coop.ui.MultilingualTable;
import softeng.coop.ui.data.DataItem;
import softeng.coop.ui.data.DataItemContainer;
import softeng.coop.ui.dialogs.ConfirmationDialog;
import softeng.coop.ui.viewdefinitions.IModalView;
import softeng.coop.ui.viewdefinitions.IOkCancelView;
import softeng.coop.ui.viewdefinitions.ITableView;
import softeng.coop.ui.viewdefinitions.viewmodels.CommandExecutionVote;
import softeng.coop.ui.viewdefinitions.viewmodels.ElementExecutionVote;
import softeng.coop.ui.viewdefinitions.viewmodels.OkCancelViewModel;
import softeng.ui.vaadin.data.RestrictedBeanItemContainer;
import softeng.ui.vaadin.mvp.EventSubscription;
import softeng.ui.vaadin.mvp.IListener;
import softeng.ui.vaadin.mvp.IView;
import softeng.ui.vaadin.mvp.IViewListener;
import softeng.ui.vaadin.mvp.ModelEvent;
import softeng.ui.vaadin.mvp.ViewEvent;
import softeng.ui.vaadin.mvp.ViewEventSubscription;

import com.vaadin.annotations.AutoGenerated;
import com.vaadin.data.Container;
import com.vaadin.data.Property;
import com.vaadin.data.Validator;
import com.vaadin.data.Validator.InvalidValueException;
import com.vaadin.data.util.BeanItem;
import com.vaadin.data.util.BeanItemContainer;
import com.vaadin.data.util.IndexedContainer;
import com.vaadin.event.DataBoundTransferable;
import com.vaadin.event.Transferable;
import com.vaadin.event.dd.DragAndDropEvent;
import com.vaadin.event.dd.DropHandler;
import com.vaadin.event.dd.acceptcriteria.AcceptAll;
import com.vaadin.event.dd.acceptcriteria.AcceptCriterion;
import com.vaadin.terminal.ThemeResource;
import com.vaadin.ui.Alignment;
import com.vaadin.ui.Button;
import com.vaadin.ui.AbstractSelect.AbstractSelectTargetDetails;
import com.vaadin.ui.Button.ClickEvent;
import com.vaadin.ui.Table.TableDragMode;
import com.vaadin.ui.HorizontalLayout;
import com.vaadin.ui.Table;
import com.vaadin.ui.TableFieldFactory;
import com.vaadin.ui.VerticalLayout;

@SuppressWarnings("serial")
public abstract class TableComponent<P, M>
	extends CoopField<Collection<M>>
	implements ITableView<P, M> 
{
	@AutoGenerated
	private VerticalLayout mainLayout;

	@AutoGenerated
	private HorizontalLayout buttonsLayout;

	@AutoGenerated
	private Button deleteButton;

	@AutoGenerated
	private Button editButton;

	@AutoGenerated
	private Button addButton;

	@AutoGenerated
	private MultilingualTable table;

	/*- VaadinEditorProperties={"grid":"RegularGrid,20","showGrid":true,"snapToGrid":true,"snapToObject":true,"movingGuides":false,"snappingDistance":10} */

	/**
	 * Optionally, show a form for a new added item. 
	 * The new item as specified by createNewElement
	 * is passed as the model of the form.
	 * Else, if returning null, no form will be showed
	 * and the item specified by createNewElement
	 * will be added as-is. 
	 */
	protected abstract IModalView<BeanItem<M>> showAddForm(BeanItem<M> item);
	
	/**
	 * Optionally, show a form to edit the selected item. 
	 * The selected item
	 * is passed as the model of the form.
	 * Else, if returning null, no form will be showed
	 * no edit will take place.
	 */
	protected abstract IModalView<BeanItem<M>> showEditForm(BeanItem<M> item);
	
	/**
	 * Specifies a contract for dynamically generated table captions.
	 */
	public interface CaptionGenerator
	{
		/**
		 * Get the caption for the column which specified this caption generator.
		 * @param context The application context. Contains current locale.
		 * @return Returns the appropriate caption string.
		 */
		String getCaption(ICoopContext context);
	}
	
	/**
	 * Specifies a column of the table.
	 */
	public static class ColumnSpecification
	{
		private String propertyId;
		private String captionResourceId;
		private Table.ColumnGenerator columnGenerator;
		private CaptionGenerator captionGenerator;
		
		public ColumnSpecification(String propertyId, String captionResourceId, Table.ColumnGenerator columnGenerator)
		{
			if (propertyId == null) 
				throw new IllegalArgumentException("Argument 'propertyId' must not be null.");
			
			this.propertyId = propertyId;
			this.captionResourceId = captionResourceId;
			this.columnGenerator = columnGenerator;
		}
		
		public ColumnSpecification(String propertyId, String captionResourceId)
		{
			this(propertyId, captionResourceId, null);
		}
		
		public ColumnSpecification(String propertyId, Table.ColumnGenerator columnGenerator, CaptionGenerator captionGenerator)
		{
			if (propertyId == null) 
				throw new IllegalArgumentException("Argument 'propertyId' must not be null.");
			
			this.propertyId = propertyId;
			this.columnGenerator = columnGenerator;
			this.captionGenerator = captionGenerator;
		}
		
		public ColumnSpecification()
		{
		}

		/**
		 * The property id of the column.
		 * If this is a real column, this is the name of the field of the object.
		 * If it is generated column, it can be anything. It may overlap a real column.
		 */
		public String getPropertyId()
		{
			return propertyId;
		}
		public void setPropertyId(String propertyId)
		{
			if (propertyId == null) 
				throw new IllegalArgumentException("Argument 'propertyId' must not be null.");
			
			this.propertyId = propertyId;
		}

		/**
		 * If not null, specifies a resource key in the associated resources of the class
		 * for multilingual column caption. Else, if property 'captionGenerator' is not null,
		 * this is called for caption generation. If both properties are null, the caption
		 * is the property id.
		 */
		public String getCaptionResourceId()
		{
			return captionResourceId;
		}
		public void setCaptionResourceId(String captionResourceId)
		{
			this.captionResourceId = captionResourceId;
		}

		public void setColumnGenerator(Table.ColumnGenerator columnGenerator)
		{
			this.columnGenerator = columnGenerator;
		}

		public Table.ColumnGenerator getColumnGenerator()
		{
			return columnGenerator;
		}

		public void setCaptionGenerator(CaptionGenerator captionGenerator)
		{
			this.captionGenerator = captionGenerator;
		}

		public CaptionGenerator getCaptionGenerator()
		{
			return captionGenerator;
		}
		
	}
	
	/**
	 * A specification for a generated column which may be added
	 * or deleted at runtime. Appears after the end of other 
	 * normal columns specified by ColumnSpecification. 
	 */
	public static class DynamicColumnSpecification
	{
		private String propertyId;
		private Table.ColumnGenerator columnGenerator;
		private CaptionGenerator captionGenerator;
		
		public DynamicColumnSpecification(
				String propertyId, 
				Table.ColumnGenerator columnGenerator, 
				CaptionGenerator captionGenerator)
		{
			if (propertyId == null) 
				throw new IllegalArgumentException("Argument 'propertyId' must not be null.");
			if (columnGenerator == null) 
				throw new IllegalArgumentException("Argument 'columnGenerator' must not be null.");
			if (captionGenerator == null) 
				throw new IllegalArgumentException("Argument 'captionGenerator' must not be null.");
			
			this.propertyId = propertyId;
			this.columnGenerator = columnGenerator;
			this.captionGenerator = captionGenerator;
		}

		public String getPropertyId()
		{
			return propertyId;
		}

		public void setPropertyId(String propertyId)
		{
			if (propertyId == null) 
				throw new IllegalArgumentException("Argument 'propertyId' must not be null.");

			this.propertyId = propertyId;
		}

		public Table.ColumnGenerator getColumnGenerator()
		{
			return columnGenerator;
		}

		public void setColumnGenerator(Table.ColumnGenerator columnGenerator)
		{
			if (columnGenerator == null) 
				throw new IllegalArgumentException("Argument 'columnGenerator' must not be null.");

			this.columnGenerator = columnGenerator;
		}

		public CaptionGenerator getCaptionGenerator()
		{
			return captionGenerator;
		}

		public void setCaptionGenerator(CaptionGenerator captionGenerator)
		{
			if (captionGenerator == null) 
				throw new IllegalArgumentException("Argument 'captionGenerator' must not be null.");

			this.captionGenerator = captionGenerator;
		}
	}
	
	/**
	 * Standard drop handler which allows row re-ordering.
	 */
	public class ReorderDropHandler
	implements DropHandler
	{

		@SuppressWarnings("unchecked")
		@Override
		public void drop(DragAndDropEvent event)
		{
			if (isReadOnly()) return;
			
			Transferable transferable = event.getTransferable();
			
			if (!(transferable instanceof DataBoundTransferable)) return;

			DataBoundTransferable dataBoundTransferable = (DataBoundTransferable)transferable;
			
			if (!dataBoundTransferable.getSourceContainer().equals(container)) return;

			if (dataBoundTransferable.getItemId() == null) return;
			
			if (!(getType().isAssignableFrom(dataBoundTransferable.getItemId().getClass()))) return;
			
			M dragged = (M)dataBoundTransferable.getItemId();
			
			AbstractSelectTargetDetails targetDetails = 
				(AbstractSelectTargetDetails)event.getTargetDetails();
			
			M dropTarget = (M)targetDetails.getItemIdOver();
			
			int dropTargetIndex = elementsCount() - 1;
			
			if (dropTarget != null)
			{
				switch (targetDetails.getDropLocation())
				{
					case MIDDLE:
					case TOP:
						dropTargetIndex = indexOfElement(dropTarget);
						break;
						
					case BOTTOM:
						dropTargetIndex = indexOfElement(dropTarget) + 1;
						break;
				}
			}

			moveElement(dragged, dropTargetIndex);
		}

		@Override
		public AcceptCriterion getAcceptCriterion()
		{
			return AcceptAll.get();
		}
	}
	
	private List<ColumnSpecification> columnSpecifications;
	
	private List<DynamicColumnSpecification> dynamicColumnSpecifications =
		new ArrayList<TableComponent.DynamicColumnSpecification>();
	
	private P parentModel;
	
	private EventSubscription<ModelEvent<M>, IListener<ModelEvent<M>>> addingSubscription =
		new EventSubscription<ModelEvent<M>, IListener<ModelEvent<M>>>();
	
	private EventSubscription<ModelEvent<M>, IListener<ModelEvent<M>>> editingSubscription = 
		new EventSubscription<ModelEvent<M>, IListener<ModelEvent<M>>>(); 

	private EventSubscription<ModelEvent<M>, IListener<ModelEvent<M>>> deletingSubscription = 
		new EventSubscription<ModelEvent<M>, IListener<ModelEvent<M>>>();
	
	private EventSubscription<ModelEvent<M>, IListener<ModelEvent<M>>> selectedChangeSubscription =
		new EventSubscription<ModelEvent<M>, IListener<ModelEvent<M>>>();
	
	private ViewEventSubscription<Collection<M>, ICoopContext, ITableView<P, M>> parentModelSubscription =
		new ViewEventSubscription<Collection<M>, ICoopContext, ITableView<P,M>>();
	
	private EventSubscription<ElementExecutionVote<M>, IListener<ElementExecutionVote<M>>> canAddSubscription =
		new EventSubscription<ElementExecutionVote<M>, IListener<ElementExecutionVote<M>>>();
	
	private EventSubscription<ElementExecutionVote<M>, IListener<ElementExecutionVote<M>>> canEditSubscription =
		new EventSubscription<ElementExecutionVote<M>, IListener<ElementExecutionVote<M>>>();
	
	private EventSubscription<ElementExecutionVote<M>, IListener<ElementExecutionVote<M>>> canDeleteSubscription =
		new EventSubscription<ElementExecutionVote<M>, IListener<ElementExecutionVote<M>>>();
	
	private EventSubscription<CommandExecutionVote, IListener<CommandExecutionVote>> preAddSubscription = 
		new EventSubscription<CommandExecutionVote, IListener<CommandExecutionVote>>();
	
	private BeanItemContainer<M> container;
	
	private List<M> addedItems = new ArrayList<M>();
	
	private List<M> removedItems = new ArrayList<M>();

	/**
	 * The constructor should first build the main layout, set the
	 * composition root and then do any custom initialization.
	 *
	 * The constructor will not be automatically regenerated by the
	 * visual editor.
	 */
	public TableComponent(List<ColumnSpecification> columnSpecifications)
	{
		if (columnSpecifications == null) 
			throw new IllegalArgumentException("Argument 'columnSpecifications' must not be null.");
		
		this.columnSpecifications = columnSpecifications;
		
		this.setDynamicColumnSpecifications(new ArrayList<DynamicColumnSpecification>());
		
		buildMainLayout();
		setCompositionRoot(mainLayout);

		setHeight("160px");
		
		setupGeneratedColumns();
		
		setupListeners();
	}
	
	public TableComponent(String caption, List<ColumnSpecification> columnSpecifications)
	{
		this(columnSpecifications);
		
		this.setCaption(caption);
	}
	
	private static Container createEmptyContainer()
	{
		IndexedContainer container = new IndexedContainer();
		return container;
	}

	private void setupListeners()
	{
		this.table.addListener(new Property.ValueChangeListener()
		{
			@Override
			public void valueChange(Property.ValueChangeEvent event)
			{
				onSelectedChange();
			}
		});

		this.addButton.addListener(new Button.ClickListener()
		{
			@Override
			public void buttonClick(ClickEvent event)
			{
				add();
			}
		});
		
		this.editButton.addListener(new Button.ClickListener()
		{
			@Override
			public void buttonClick(ClickEvent event)
			{
				edit();
			}
		});
		
		this.deleteButton.addListener(new Button.ClickListener()
		{
			@Override
			public void buttonClick(ClickEvent event)
			{
				delete();
			}
		});

		this.addModelChangeListener(new IViewListener<Collection<M>, ICoopContext, IView<Collection<M>,ICoopContext>>()
		{
			@Override
			public void onEvent(ViewEvent<Collection<M>, ICoopContext, IView<Collection<M>, ICoopContext>> event)
			{
				addedItems.clear();
				removedItems.clear();
			}
		});

	}

	@SuppressWarnings("unchecked")
	protected BeanItemContainer<M> createBeanItemContainer(Collection<M> collection)
	{
		RestrictedBeanItemContainer<M> container = 
			//new RestrictedBeanItemContainer<M>((Class<M>)this.getType(), collection);
			new DataItemContainer<M>((Class<M>)this.getType(), collection, getContext().getSession().getBaseManager());
		
		container.setContainerPropertyIds(getSpecifiedPropertyIds());
		
		return container;
		
		//return new BeanItemContainer<M>((Class<M>)this.getType(), collection);
	}

	@Override
	public void dataBind()
	{
		this.addedItems.clear();
		this.removedItems.clear();
		
		if (this.getModel() != null)
		{
			this.container = 
				this.createBeanItemContainer(this.getModel());
			
			this.table.setContainerDataSource(this.container);
	
			Collection<String> visiblePropertyIds = getVisiblePropertyIds();
			
			this.table.setVisibleColumns(visiblePropertyIds.toArray());
		}
		else
		{
			this.container = null;
			this.table.setContainerDataSource(createEmptyContainer());
		}

		// Only invoke translation services if the application is available.
		// Else, defer translation to setupLocalizedCaptions.
		if (this.getApplication()!= null)
		{
			setupLocalizedTableHeaders();
		}
		
	}
	
	/**
	 * Returns all the property IDs defined that are real, not generated columns.
	 */
	public Collection<String> getSpecifiedPropertyIds()
	{
		Vector<String> list = 
			new Vector<String>(this.columnSpecifications.size());
		
		for (ColumnSpecification specification : this.columnSpecifications)
		{
			if (specification.getColumnGenerator() != null) continue;
			
			list.add(specification.getPropertyId());
		}
		
		return list;
	}
	
	/**
	 * Returns all the property IDs, including generated and dynamic columns.
	 */
	public Collection<String> getVisiblePropertyIds()
	{
		Vector<String> list = 
			new Vector<String>(this.columnSpecifications.size());
		
		for (ColumnSpecification specification : this.columnSpecifications)
		{
			list.add(specification.getPropertyId());
		}
		
		for (DynamicColumnSpecification specification : this.dynamicColumnSpecifications)
		{
			list.add(specification.getPropertyId());
		}
		
		return list;
	}
	
	private void setupLocalizedTableHeaders()
	{
		ICoopContext context = getContext();
		
		// Predefined columns.
		for (ColumnSpecification specification : this.columnSpecifications)
		{
			if (specification.getCaptionResourceId() != null)
				table.setColumnHeader(specification.getPropertyId(), getLocalizedString(specification.getCaptionResourceId()));
			else if (specification.getCaptionGenerator() != null)
				table.setColumnHeader(specification.getPropertyId(), specification.getCaptionGenerator().getCaption(context));
		}
		
		// Dynamic columns.
		for (DynamicColumnSpecification specification : this.dynamicColumnSpecifications)
		{
			table.setColumnHeader(specification.getPropertyId(), specification.getCaptionGenerator().getCaption(context));
		}
		
		// Refresh the contents by re-binding.
		if (this.container != null)
		{
			table.refreshRowCache();
		}
	}

	@Override
	public void addAddingListener(IListener<ModelEvent<M>> listener)
	{
		this.addingSubscription.add(listener);
	}

	@Override
	public void removeAddingListener(IListener<ModelEvent<M>> listener)
	{
		this.addingSubscription.remove(listener);
	}

	@Override
	public void addEditingListener(IListener<ModelEvent<M>> listener)
	{
		this.editingSubscription.add(listener);
	}

	@Override
	public void removeEditingListener(IListener<ModelEvent<M>> listener)
	{
		this.editingSubscription.remove(listener);
	}

	@Override
	public void addDeletingListener(IListener<ModelEvent<M>> listener)
	{
		this.deletingSubscription.add(listener);
	}

	@Override
	public void removeDeletingListener(IListener<ModelEvent<M>> listener)
	{
		this.deletingSubscription.remove(listener);
	}
	
	@Override
	public P getParentModel()
	{
		return this.parentModel;
	}
	
	@Override
	public void setParentModel(P parentModel)
	{
		this.parentModel = parentModel;
		
		this.parentModelSubscription.fire(
				new ViewEvent<Collection<M>, ICoopContext, ITableView<P,M>>(this));
	}

	@Override
	protected void setupUI()
	{
		super.setupUI();
		
		this.addButton.setIcon(new ThemeResource("../images/actions/add.png"));
		this.editButton.setIcon(new ThemeResource("../images/actions/edit.png"));
		this.deleteButton.setIcon(new ThemeResource("../images/actions/trash.png"));
		
		this.addButton.setCaption(null);
		this.editButton.setCaption(null);
		this.deleteButton.setCaption(null);
		
		this.table.setSelectable(true);
		
	}

	protected void onSelectedChange()
	{
		selectedChangeSubscription.fire(
				new ModelEvent<M>(getSelectedValue()));
	}

	protected void edit()
	{
		if (container == null) return;
		
		final BeanItem<M> selectedItem = getSelectedItem();
		
		if (selectedItem == null) return;
		
		if (!canEdit(selectedItem.getBean())) return;
		
		final IModalView<BeanItem<M>> form = this.showEditForm(selectedItem);
		
		if (form == null) return;
		
		form.setReadOnly(this.isReadOnly());
		
		form.getOkCancelView().addOkListener(new IViewListener<OkCancelViewModel, ICoopContext, IOkCancelView>()
		{
			@Override
			public void onEvent(ViewEvent<OkCancelViewModel, ICoopContext, IOkCancelView> event)
			{
				if (!form.isDataValid()) return;
				
				ModelEvent<M> modelEvent = new ModelEvent<M>(selectedItem.getBean());

				editingSubscription.fire(modelEvent);
				
				updateValidationMarking();
			}
		});
		
	}

	@Override
	public BeanItem<M> getSelectedItem()
	{
		if (container == null) return null;
		
		BeanItem<M> selectedItem = 
			this.container.getItem(this.table.getValue());
		
		return selectedItem;
	}

	protected void delete()
	{
		if (container == null || this.isReadOnly()) return;
		
		BeanItem<M> selectedItem = this.getSelectedItem();
		
		if (selectedItem == null) return;
		
		if (!canDelete(selectedItem.getBean())) return;
		
		String confirmationCaption = getContext().getLocalizedString("DELETE_CONFIRMATION_CAPTION");
		String confirmationDescription = getContext().getLocalizedString("DELETE_CONFIRMATION_DESCRIPTION");
		
		ConfirmationDialog dialog = 
			new ConfirmationDialog(
					confirmationCaption, 
					confirmationDescription);
		
		dialog.getOkCancelView().addOkListener(new IViewListener<OkCancelViewModel, ICoopContext, IOkCancelView>()
		{
			@Override
			public void onEvent(ViewEvent<OkCancelViewModel, ICoopContext, IOkCancelView> event)
			{
				onDeleteConfirmation();
			}
		});
		
		dialog.getOkCancelView().addOkFailedListener(new IListener<RuntimeException>()
		{
			@Override
			public void onEvent(RuntimeException event)
			{
				throw event;
			}
		});
		
		this.getApplication().getMainWindow().addWindow(dialog);
	}

	protected void onDeleteConfirmation()
	{
		if (container == null || this.isReadOnly()) return;
		
		BeanItem<M> selectedItem = this.getSelectedItem();
		
		deletingSubscription.fire(new ModelEvent<M>(selectedItem.getBean()));

		this.container.removeItem(selectedItem.getBean());
		
		this.removedItems.add(selectedItem.getBean());
		
		if (this.isWriteThrough()) this.commit();
		
		this.table.setValue(null);
		
		updateValidationMarking();
	}

	protected void add()
	{
		if (container == null || this.isReadOnly()) return;
		
		CommandExecutionVote preAddVote = new CommandExecutionVote();
		
		preAddSubscription.fire(preAddVote);
		
		if (preAddVote.isFailed()) return;
		
		final M newElement = this.createNewElement();
		
		final BeanItem<M> newItem = createItem(newElement);
		
		final IModalView<BeanItem<M>> form = this.showAddForm(newItem);
		
		if (form != null)
		{
			form.getOkCancelView().addOkListener(new IViewListener<OkCancelViewModel, ICoopContext, IOkCancelView>()
			{
				@Override
				public void onEvent(ViewEvent<OkCancelViewModel, ICoopContext, IOkCancelView> event)
				{
					if (!form.isDataValid() || form.getModel() == null) return;
					
					BeanItem<M> selectedItem = form.getModel();
					
					M selected = selectedItem.getBean();
					
					addElement(selected);
				}
			});
		}
		else
		{
			if (newElement == null) return;
			
			// If no add form was provided, add the new item directly, with no edit dialog.
			
			addElement(newElement);
		}
	}

	protected BeanItem<M> createItem(M obj)
	{
		if (obj != null)
			//return new BeanItem<M>(obj);
			return new DataItem<M>(obj, getContext().getSession().getBaseManager());
		else
			return null;
	}

	@Override
	protected void setupLocalizedCaptions(Locale locale)
	{
		super.setupLocalizedCaptions(locale);
		
		setupLocalizedTableHeaders();
		
		updateButtonCaptions();
	}

	public void updateButtonCaptions()
	{
		this.addButton.setDescription(getContext().getLocalizedString("ADD_CAPTION"));
		this.editButton.setDescription(getContext().getLocalizedString("EDIT_CAPTION"));
		this.deleteButton.setDescription(getContext().getLocalizedString("DELETE_CAPTION"));
	}
	
	protected abstract M createNewElement();

	@Override
	public void addParentModelChangeListener(IViewListener<Collection<M>, ICoopContext, ITableView<P, M>> listener)
	{
		parentModelSubscription.add(listener);
	}

	@Override
	public void removeParentModelChangeListener(IViewListener<Collection<M>, ICoopContext, ITableView<P, M>> listener)
	{
		parentModelSubscription.remove(listener);
	}
	
	public @Override boolean isReadOnly()
	{
		return super.isReadOnly();
	}
	
	@Override
	public void setReadOnly(boolean readOnly)
	{
		super.setReadOnly(readOnly);
		
		this.addButton.setEnabled(!readOnly);
		/* New policy: Let the read-only field to present a read-only browser. */
		//this.editButton.setEnabled(!readOnly);
		this.deleteButton.setEnabled(!readOnly);
	}
	
	@Override
	public void commit()
	{
		if (getModel() != null && container != null &&
				(isInvalidCommitted() || isValid()))
		{
			for (M removedItem : removedItems)
			{
				removeFromParent(removedItem);
			}
			
			// Does the container support order?
			// If yes, take care of the items order.
			if (getModel() instanceof List)
			{
				List<M> list = (List<M>)getModel();
				
				list.clear();
				
				for (int currentIndex = 0; currentIndex < container.size(); currentIndex++)
				{
					M element = container.getIdByIndex(currentIndex);
					
					list.add(element);
				}
			}
			else
			{
				getModel().removeAll(removedItems);
				
				getModel().addAll(addedItems);
			}
			
			for (M addedItem : addedItems)
			{
				addToParent(addedItem);
			}
			
			addedItems.clear();
			
			removedItems.clear();
		}
	}
	
	/**
	 * Optionally, attach to parent for a more consistent domain.
	 * @param parent If the item added.
	 */
	protected void addToParent(M item)
	{
		// NOP by default. Attach to parent for a more consistent
		// domain.
	}
	
	/**
	 * Optionally, remove from parent for a more consistent domain.
	 * @param parent If the item removed.
	 */
	protected void removeFromParent(M item)
	{
		// NOP by default. Remove from parent for a more consistent
		// domain.
	}
	
	@Override
	public void discard()
	{
		if (this.getPropertyDataSource() != null)
		{
			this.container.addAll(removedItems);
			
			for (M addedItem : this.addedItems)
			{
				this.container.removeItem(addedItem);
			}
			
			this.removedItems.clear();
			this.addedItems.clear();
		}
	}
	
	public boolean isEditVisible()
	{
		return this.editButton.isVisible();
	}
	
	public void setEditVisible(boolean visible)
	{
		this.editButton.setVisible(visible);
	}

	public boolean isAddVisible()
	{
		return this.addButton.isVisible();
	}
	
	public void setAddVisible(boolean visible)
	{
		this.addButton.setVisible(visible);
	}
	
	public boolean isDeleteVisible()
	{
		return this.deleteButton.isVisible();
	}
	
	public void setDeleteVisible(boolean visible)
	{
		this.deleteButton.setVisible(visible);
	}
	
	@SuppressWarnings("unchecked")
	@Override
	public M getSelectedValue()
	{
		return (M)this.table.getValue();
	}
	
	@Override
	public void setSelectedValue(M value)
	{
		this.table.setValue(value);
		
		if (value != null)
		{
			this.table.setCurrentPageFirstItemId(value);
		}
	}
	
	@Override
	public void addSelectedChangeListener(IListener<ModelEvent<M>> listener)
	{
		selectedChangeSubscription.add(listener);
	}
	
	@Override
	public void removeSelectedChangeListener(IListener<ModelEvent<M>> listener)
	{
		selectedChangeSubscription.remove(listener);	
	}

	@Override
	public void setImmediate(boolean immediate)
	{
		super.setImmediate(immediate);
		
		this.table.setImmediate(immediate);
	}

	@AutoGenerated
	private VerticalLayout buildMainLayout()
	{
		// common part: create layout
		mainLayout = new VerticalLayout();
		mainLayout.setImmediate(false);
		mainLayout.setWidth("100%");
		mainLayout.setHeight("100%");
		mainLayout.setMargin(false);
		mainLayout.setSpacing(true);
		
		// top-level component properties
		setWidth("100.0%");
		setHeight("100.0%");
		
		// table
		table = new MultilingualTable();
		table.setImmediate(false);
		table.setWidth("100.0%");
		table.setHeight("100.0%");
		mainLayout.addComponent(table);
		mainLayout.setExpandRatio(table, 1.0f);
		
		// buttonsLayout
		buttonsLayout = buildButtonsLayout();
		mainLayout.addComponent(buttonsLayout);
		mainLayout.setComponentAlignment(buttonsLayout, new Alignment(6));
		
		return mainLayout;
	}

	@AutoGenerated
	private HorizontalLayout buildButtonsLayout()
	{
		// common part: create layout
		buttonsLayout = new HorizontalLayout();
		buttonsLayout.setImmediate(false);
		buttonsLayout.setWidth("-1px");
		buttonsLayout.setHeight("-1px");
		buttonsLayout.setMargin(false);
		buttonsLayout.setSpacing(true);
		
		// addButton
		addButton = new Button();
		addButton.setCaption("Button");
		addButton.setImmediate(true);
		addButton.setWidth("48px");
		addButton.setHeight("-1px");
		buttonsLayout.addComponent(addButton);
		buttonsLayout.setExpandRatio(addButton, 1.0f);
		
		// editButton
		editButton = new Button();
		editButton.setCaption("Button");
		editButton.setImmediate(true);
		editButton.setWidth("48px");
		editButton.setHeight("-1px");
		buttonsLayout.addComponent(editButton);
		buttonsLayout.setExpandRatio(editButton, 1.0f);
		buttonsLayout.setComponentAlignment(editButton, new Alignment(20));
		
		// deleteButton
		deleteButton = new Button();
		deleteButton.setCaption("Button");
		deleteButton.setImmediate(true);
		deleteButton.setWidth("48px");
		deleteButton.setHeight("-1px");
		buttonsLayout.addComponent(deleteButton);
		buttonsLayout.setExpandRatio(deleteButton, 1.0f);
		buttonsLayout.setComponentAlignment(deleteButton, new Alignment(6));
		
		return buttonsLayout;
	}

	/**
	 * The field factory used to build table cells.
	 * It only takes effect when the component's 'editable' property is true.
	 */
	public TableFieldFactory getFieldFactory()
	{
		return table.getTableFieldFactory();
	}

	/**
	 * The field factory used to build table cells.
	 * It only takes effect when the component's 'editable' property is true.
	 */
	public void setFieldFactory(TableFieldFactory fieldFactory)
	{
		this.table.setTableFieldFactory(fieldFactory);
	}

	@Override
	public void addCanAddListener(IListener<ElementExecutionVote<M>> listener)
	{
		canAddSubscription.add(listener);
	}

	@Override
	public void removeCanAddListener(IListener<ElementExecutionVote<M>> listener)
	{
		canAddSubscription.remove(listener);
	}

	@Override
	public void addCanEditListener(IListener<ElementExecutionVote<M>> listener)
	{
		canEditSubscription.add(listener);
	}

	@Override
	public void removeCanEditListener(IListener<ElementExecutionVote<M>> listener)
	{
		canEditSubscription.remove(listener);
	}

	@Override
	public void addCanDeleteListener(IListener<ElementExecutionVote<M>> listener)
	{
		canDeleteSubscription.add(listener);
	}

	@Override
	public void removeCanDeleteListener(IListener<ElementExecutionVote<M>> listener)
	{
		canDeleteSubscription.remove(listener);
	}
	
	/**
	 * Returns true if the selected element can be added.
	 * By default, it fires the canAdd event to listeners and returns their vote.
	 * @param element The element in question.
	 * @return Returns true of the element can be added.
	 */
	protected boolean canAdd(M element)
	{
		ElementExecutionVote<M> vote = new ElementExecutionVote<M>(element);
		
		canAddSubscription.fire(vote);
		
		return !vote.isFailed();
	}
	
	/**
	 * Returns true if the selected element can be edited.
	 * By default, it fires the canEdit event to listeners and returns their vote.
	 * @param element The element in question.
	 * @return Returns true of the element can be edited.
	 */
	protected boolean canEdit(M element)
	{
		ElementExecutionVote<M> vote = new ElementExecutionVote<M>(element);
		
		canEditSubscription.fire(vote);
		
		return !vote.isFailed();
	}
	
	/**
	 * Returns true if the selected element can be deleted.
	 * By default, it fires the canDelete event to listeners and returns their vote.
	 * @param element The element in question.
	 * @return Returns true of the element can be deleted.
	 */
	protected boolean canDelete(M element)
	{
		ElementExecutionVote<M> vote = new ElementExecutionVote<M>(element);
		
		canDeleteSubscription.fire(vote);
		
		return !vote.isFailed();
	}
	
	/**
	 * True if the rows in the table are editable, else false.
	 * Default is false.
	 */
	public boolean isEditable()
	{
		return table.isEditable();
	}
	
	/**
	 * True if the rows in the table are editable, else false.
	 * Default is false.
	 */
	public void setEditable(boolean editable)
	{
		table.setEditable(editable);
	}

	@Override
	public DropHandler getDropHandler()
	{
		return table.getDropHandler();
	}
	
	@Override
	public void setDropHandler(DropHandler dropHandler)
	{
		table.setDropHandler(dropHandler);
	}
	
	@Override
	public TableDragMode getDragMode()
	{
		return table.getDragMode();
	}
	
	@Override
	public void setDragMode(TableDragMode dragMode)
	{
		table.setDragMode(dragMode);
	}

	private void setupGeneratedColumns()
	{
		for (ColumnSpecification columnSpecification : columnSpecifications)
		{
			if (columnSpecification.getColumnGenerator() != null)
			{
				table.addGeneratedColumn(
						columnSpecification.getPropertyId(), 
						columnSpecification.getColumnGenerator());
			}
		}
	}

	public void setDynamicColumnSpecifications(List<DynamicColumnSpecification> dynamicColumnSpecifications)
	{
		if (dynamicColumnSpecifications == null) 
			dynamicColumnSpecifications = new ArrayList<DynamicColumnSpecification>();
		
		clearDynamicColumns();
		
		this.dynamicColumnSpecifications = dynamicColumnSpecifications;
		
		setupDynamicColumns();
	}

	public List<DynamicColumnSpecification> getDynamicColumnSpecifications()
	{
		return dynamicColumnSpecifications;
	}

	private void setupDynamicColumns()
	{
		ICoopContext context = getContext();
		
		for (DynamicColumnSpecification specification : this.dynamicColumnSpecifications)
		{
			table.addGeneratedColumn(specification.getPropertyId(), specification.getColumnGenerator());
			table.setColumnHeader(specification.getPropertyId(), specification.getCaptionGenerator().getCaption(context));
		}
	}

	private void clearDynamicColumns()
	{
		for (DynamicColumnSpecification specification : this.dynamicColumnSpecifications)
		{
			table.removeGeneratedColumn(specification.propertyId);
		}
		
		dynamicColumnSpecifications.clear();
	}
	
	@Override
	public void refreshRowCache()
	{
		table.refreshRowCache();
	}

	@Override
	public boolean isValid()
	{
		if (this.isRequired() && this.isEmpty()) return false;
		
		Container container = table.getContainerDataSource();
		
		for (Validator validator : this.getValidators())
		{
			if (container == null) continue;
			
			if (!validator.isValid(container.getItemIds())) return false;
		}
		
		return true;

	}

	@Override
	public void validate() throws InvalidValueException
	{
		if (this.isRequired() && this.isEmpty())
			throw new Validator.EmptyValueException(getRequiredError());
		
		for (Validator validator : this.getValidators())
		{
			if (container == null) continue;
			
			validator.validate(container.getItemIds());
		}
	}
	
	@Override
	public BeanItemContainer<M> getContainer()
	{
		return container;
	}
	
	@Override
	public boolean addElement(M element)
	{
		if (element == null) 
			throw new IllegalArgumentException("Argument 'element' must not be null.");
		
		if (container == null) return false;

		if (!canAdd(element)) return false;
		
		ModelEvent<M> modelEvent = new ModelEvent<M>(element);
		
		addingSubscription.fire(modelEvent);

		container.addBean(element);
		
		table.setValue(element);
		table.setCurrentPageFirstItemId(element);
		
		addedItems.add(element);
		
		if (isWriteThrough()) commit();
		
		updateValidationMarking();
		
		return true;
	}
	
	@Override
	public boolean deleteElement(M element)
	{
		if (element == null) 
			throw new IllegalArgumentException("Argument 'element' must not be null.");
		
		if (container == null) return false;

		if (!canDelete(element)) return false;
		
		deletingSubscription.fire(new ModelEvent<M>(element));

		if (!this.container.removeItem(element)) return false;
		
		this.removedItems.add(element);
		
		if (this.isWriteThrough()) this.commit();
		
		this.table.setValue(null);
		
		updateValidationMarking();
		
		return true;
	}
	
	@Override
	public int indexOfElement(M element)
	{
		if (element == null) 
			throw new IllegalArgumentException("Argument 'element' must not be null.");
		
		if (container == null) return -1;

		return this.container.indexOfId(element);
	}

	@Override
	public void moveElement(int fromIndex, int toIndex)
	{
		if (container == null) return;

		if (fromIndex >= container.size() || fromIndex < 0)
			throw new IllegalArgumentException("Argument 'fromIndex' is out of range.");

		if (toIndex >= container.size() || toIndex < 0)
			throw new IllegalArgumentException("Argument 'toIndex' is out of range.");
		
		if (fromIndex == toIndex) return;
		
		M element = container.getIdByIndex(fromIndex);
		
		container.removeItem(element);
		
		container.addItemAt(toIndex, element);
	}
	
	@Override
	public boolean moveElement(M element, int toIndex)
	{
		if (element == null) 
			throw new IllegalArgumentException("Argument 'element' must not be null.");

		if (toIndex >= container.size() || toIndex < 0)
			throw new IllegalArgumentException("Argument 'toIndex' is out of range.");
		
		if (!container.removeItem(element)) return false;
		
		container.addItemAt(toIndex, element);
		
		return true;
	}
	
	@Override
	public int elementsCount()
	{
		return container != null ? container.size() : 0;
	}

	@Override
	public boolean isUserSelectable()
	{
		return table.isSelectable();
	}
	
	@Override
	public void setUserSelectable(boolean selectable)
	{
		table.setSelectable(selectable);
	}

	@Override
	public void addPreAddListener(IListener<CommandExecutionVote> listener)
	{
		preAddSubscription.add(listener);
	}

	@Override
	public void removePreAddListener(IListener<CommandExecutionVote> listener)
	{
		preAddSubscription.remove(listener);
	}
}
